
# Redis Cluster

## 클러스터의 기능

### 고가용성

클러스터는 각각 최소 3대의 마스터, 복제본 노드를 갖도록 구성하는것이 일번적  
하닁 클러스터 구성에 속한 각 노드는 서로를 모니터링한다(클러스터 버스 프로토콜)

마스터(MASTER) 노드에 장애가 발생하면 이를 인지한 다른 노드들이 마스터에 연결된 복제본(REPLICA) 노드를 마스터로 자동 페일오버시켜 추가적인 개입 없이 레디스의 가용성을 증가시킬 수 있다
또한 마스터에 연결된 복제본의 개수를 파악해 잉여 복제본을 필요한 노드에 연결시키는 복제본 마이그레이션 작업을 수행하기도 한다  

노드간 통신은 클러스터버스라는 독립적인 통신을 이용 (TCP 통신)  
클라이언트 TCP 포트와 독립되게 동작, cluster_bus_port 값을 정의하지 않는다면 클라이언트 포트에 10000을 더한 값으로 자동 설정  
ex) 클라이언트 포트가 6379 라면 클러스터 버스 포트는 16379 포트를 이용해 통신

모든 노드가 TCP 연결을 사용해 다른 모든 노드와 연결돼 있는 풀 메쉬(full-mesh) 토폴로지 형태  
클러스터가 N개 노드로 이뤄져 있을때, 모든 각 노드는 N-1 개의 다른 노드와 송수신 TCP 연결을 하고 있으며, 지속적 유지  
1개의 노드에서 다른 노드로 PING을 보냈을 때 PONG 응답이 늦는다면 해당 노드로의 연결을 새로 시도  

가십 프로토콜과 구성 업데이트 메커니즘을 이용해 클러스터가 정상적인 상태에서는 노드간 너무 많은 메세지 교환을 하지 않는다  
노드가 증가하더라도 메세지가 기하급수적으로 늘어나지 않도록 설계 됐다  

## 레디스 클러스터 동작 방법

### 해시슬롯을 이용한 데이터 샤딩

클러스터 구조에서 모든 데이터는 해시 슬롯에 저장  
총 16,384개의 해시슬롯을 가지며, 마스터 노드는 해시슬롯을 나눠 갖고 있다  
3대의 마스터 노드로 클러스터 구성시 해시슬롯은 아래와 같이 분배
- MASTER-1 - 0     ... 5460
- MASTER-2 - 5461  ... 10922
- MASTER-3 - 10923 ... 16383

레디스에 입력되는 모든 키는 하나의 해시슬롯에 매핑  
이때 다음의 해시함수를 사용
```
HASH_SLOT= CRC16(key) mod 16384
```
키를 CRC16으로 암호화한 다음 16384 라는 값으로 나눈 나머지 값을 이용  
이는 데이터를 읽어올 때도 위의 함수를 이용해 커맨드를 처리할 마스터 노드를 찾아감  

해시슬롯은 마스터 노드 내에서 자유롭게 옮겨질 수 있으며, 옮겨지는 중에도 데이터는 정상적으로 접근 가능  
이러한 특성으로 클러스터 내 마스터 노드의 추가, 삭제는 간단하게 처리될 수 있다  
- 마스터 추가 - 신규 레디스 노드를 마스터로 추가한 뒤 기존 노드가 가지고 있던 해시슬롯의 일부를 신규 마스터로 이동
- 마스터 삭제 - 삭제할 노드가 가지고 있는 해시슬롯을 전부 다른 마스터로 이동시킨 다음 노드를 클러스터에서 제외  

### 해시태그

클러스터 사용시 다중 키 커맨드 사용 불가  
서로 다른 해시슬롯에 속한 키에 대해서 다중 키 커맨드를 사용할 수 없다  

```
MGET user1:name user2:name
```

- MASTER-1 - user1:name
- MASTER-3 - user2:name

위와 같은 상황에서 다중 키 커맨드 사용시 클러스터에서 각각의 키는 서로 다른 해시슬롯에 저장돼 있고  
각 해시슬롯이 MASTER-1, MASTER-3 에 저장된다고 하면  
클러스터는 키를 이용해 커맨드를 처리할 마스터로 클라이언트의 연결을 리디렉션하기 때문에 한번에 2개 이상의 키에 접근해야 하는 커맨드는 처리 불가  

이때 해시태그 기능을 사용해 문제 해결  
키에 대괄호({})를 사용하면 전체 키가 아닌 대괄호 사이에 있는 값을 이용해 해시될 수 있다  

```
user:{123}:profile
user:{123}:account
```

대괄호 사이에 아무런 문자열이 없다면 다른 키들과 동일하게 전체 키의 문자열로 해싱  
여러개의 {}(대괄호) 문자가 포함된 키의 경우 가장 처음의 {부터 가장 처음의 } 사이 값들이 해싱된다  

| 키(Key)             | 해시되는 값(Value) |
|---------------------|--------------------|
| {user1000}.followers | user1000          |
| user{}id            | user{}id           |
| user{{name}}id      | {name              |
| user{name}{id}      | name               |

너무 많은 키가 같은 해시태그를 갖고 있다면 하나의 해시슬롯에 데이터가 몰리는 현상이 발생할 수 있기 때문에 키의 분배에 대한 모니터링이 필요함  

### 자동 재구성

#### 1. 복제본 노드를 마스터로 승격시키는 자동 페일오버

마스터 다운으로 복제본이 마스터로 승격된 상황에서 해당 복제본 노드까지 다운될 시  
다음 설정에 의해 클러스터 내 마스터가 하나라도 정상 상태가 아닐 경우 전체 클러스터를 사용할 수 없게 된다  

```
cluster-require-full-coverage yes
```

해당 옵션 기본값은 yes  
클러스터 내 일부 해시슬롯을 사용하지 못하게 되면, 즉 일부 노드만 다운된 경우라도 데이터의 정합성을 위해 클러스터의 전체 상태가 fail이 돼, 문제가 생긴 해시슬롯을 포함한 전체 해시슬롯에 대한 데이터의 조작도 실패  

#### 2. 잉여 복제본 노드를 다른 마스터에 연결시키는 복제본 마이그레이션 (replica migration)
  - 가용성이 중요한 서비스에서 클러스터 노드의 다운타임을 줄이고 싶다면  
  - 자동 복제본 마이그레이션이 가능하도록 아무 마스터 노드에 복제본을 하나 더 추가하는 것

가장 많은 수의 복제본이 연결된 마스터의 복제본 중 하나가 옮겨지게 되며, FAIL 상태가 아닌 복제본 중 노드 ID가 가장 작은 복제본이 이동될 노드로 선택된다  

```
cluster-allow-replica-migration yes
cluster-migration-barrier 1
```

마이그레이션은 cluster-allow-replica-migration 옵션이 yes 일때 동작, 기본값은 yes  
cluster-migration-barrier 는 복제본을 마이그레이션하기 전 마스터가 가지고 있어야 할 최소 복제본의 수를 의미  

cf. config

- cluster-require-full-coverage : cluster의 일부 node가 다운된 경우 클러스터의 상태를 결정합니다.
  - yes : slave가 없는 master가 다운되면 cluster 전체가 중지
  - no : slave가 없는 master가 다운되더라도 cluster는 유지. 다운된 master의 슬롯에서만 에러가 발생.
  - 일부 데이터가 유실돼도 괜찮으면 no, 데이터의 정합성이 중요하다면 yes를 선택.
  - no로 설정하더라도 절반 이상의 node가 down 되면 cluster는 중지됩니다.

ref) [https://kominjae.tistory.com/261](https://kominjae.tistory.com/261)

